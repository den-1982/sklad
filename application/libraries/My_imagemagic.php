<?php/**	get_resourse      - возвращает ресурс изображения параметры: 1-полный путь к изображению*	*	BASE_64           - Возвращает изображение в BASE64*						параметры:*						1-ресурс изображения *				        2-задаем ширину*				        3-качество от 0 до 100 *	upload            - обычная загрузка изображения (переводит все типы к JPG)*						параметры:*						1-ресурс изображения *				        2-полный путь куда сохранять новое изображение*				        3-качество от 0 до 100 *	*	image_flip        - зеркальное отражение по горизонтали *				        параметры: *				        1-ресурс изображения *				        2-полный путь куда сохранять новое изображение *				        3-качество от 0 до 100 *				   *	wm                - наложение водяного знака. Водяной знак должен быть (квадрат) например 600\600px, тип - .PNG, функция устанавливает wm по середине, *				        параметры: *				        1-полный путь к изображению (JPEG), *				        2-полный путь куда сохранять новое изображение*				        3-полный путь к wm*				        4-качество от 0 до 100 **	textura           - наложение текстуры. Тип - .PNG *				        параметры: *				        1-полный путь к изображению (JPEG), *				        2-полный путь куда сохранять новое изображение*				        3-полный путь к TEXTURA (PNG)*				        4-качество от 0 до 100 **	black_white       - делает черно-белое изображение*				        параметры:*				        1-полный путь к изображению*				        2-полный путь куда сохранять новое изображение*				        3-качество от 0 до 100 * *	sepia             - делает изображение сепия*				        параметры:*				        1-полный путь к изображению*				        2-полный путь куда сохранять новое изображение*				        3-качество от 0 до 100 * *	negativ           - делает изображение негатив*				        параметры:*				        1-полный путь к изображению*				        2-полный путь куда сохранять новое изображение*				        3-качество от 0 до 100 * *	resize_background - изменяем размер изображения сохраняя пропорции, при этом изобр. становится квадратным с установленным background*					    параметры:*						1-полный путь к изображению*				       	2-полный путь куда сохранять новое изображение*						3-новая ширина (width)px*						4-новая длина (height)px*						5-цвет (background) - пустое пространство будет заполнено этим цветом*						пример: 0x2805fe - (без ковычек, впереди пишется 0x и HEX-2805fe*				        6-качество от 0 до 100 *						*	resize            - измененить размер изображения с сохранением пропорций. Если размер картинки меньше заданного - вернет FALSE*						параметры:*						1-полный путь к изображению*				       	2-полный путь куда сохранять новое изображение*						3-задаём размер (если из. 400\500 - задали 100 = 100\125)*				        4-качество от 0 до 100 **	resize_2          - измененить размер изображения с сохранением пропорций. Если размер картинки меньше заданного - вернет FALSE *						параметры:*						1-полный путь к изображению*				       	2-полный путь куда сохранять новое изображение*						3-задаём ширину*						4-задаём высоту (если задали 240\200 то 450\300 -> 240\155;  230\445 -> 102\200)*				        5-качество от 0 до 100 **	resize_square     - измененить размер изображения на квадрат без сохранением пропорций, обрезае те части - которые не влазят в заданый размер. Если размер картинки меньше заданного - вернет FALSE*		                параметры:*						1-полный путь к изображению*				       	2-полный путь куда сохранять новое изображение*						3-задаём размер (если из. 400\500 - задали 100 = 100\100)*				        4-качество от 0 до 100 **	crop              - вырезаем кусок изображения*		                параметры:*						1-полный путь к изображению*				       	2-полный путь куда сохранять новое изображение*						3-задаём ширину*						4-задаём высоту*				        5-качество от 0 до 100 **	colorator         - вычесляет преоблодание цвета в изображении. На выходе получаем массив 12-ти цветов с их процентным соотношении. *		                параметры:*						1-полный путь к изображению**/class My_imagemagic{		public function get_resourse($url){		$size  = @getimagesize($url);		$image = false;		switch($size[2]){			case 1: $image = @imagecreatefromgif($url);				break;			case 2: $image = @imagecreatefromjpeg($url);				break;			case 3: $image = @imagecreatefrompng($url);				break;			case 4: $image = false;				break;			case 5: $image = false;				break;			case 6: $image = false;				break;			case 7: $image = false;				break;			default: $image = false;		}		return $image;	}//-----------------------------------------------------------------------------------UPLOAD		public function upload($in, $out, $q = 100){		if ( ! $in = $this->get_resourse($in)) 			return false;				imagejpeg($in, $out, $q);		imagedestroy($in);		return true;	}//-----------------------------------------------------------------------------------UPLOAD_PNG		public function upload_PNG($in, $out, $q = 0){		if(!$in = $this->get_resourse($in)) 			return false;				imagealphablending($in, false);		imagesavealpha($in, true);		imagepng($in, $out, $q);		imagedestroy($in);		return true;	}//-----------------------------------------------------------------------------------UPLOAD		public function base64($in, $size, $q = 100){		if(!$in = $this->get_resourse($in))			return false;				$w = imagesx($in);		$h = imagesy($in);		if($w > $h){			$kf    = $w/$size; 			$new_h = ceil($h/$kf);			$im1 = imagecreatetruecolor($size, $new_h);			imagecopyresampled($im1,$in,0,0,0,0,$size,$new_h,imagesx($in),imagesy($in));		}else{			$kf    = $h/$size; 			$new_w = ceil($w/$kf);			$im1 = imagecreatetruecolor($new_w, $size);			imagecopyresampled($im1,$in,0,0,0,0,$new_w,$size,imagesx($in),imagesy($in));		}				ob_start();		imagejpeg($im1, null, $q);		$contents =  ob_get_contents();		ob_end_clean();		imagedestroy($in);		imagedestroy($im1);				return base64_encode($contents);	}//-----------------------------------------------------------------------------------CROPpublic function crop($in, $out, $w, $h, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;						$tmp = imagecreatetruecolor($w, $h); 				$w_src = imagesx($in);		$h_src = imagesy($in);				imagecopyresized($tmp,$in,0,0,0,0,imagesx($in),imagesy($in),imagesx($in),imagesy($in)); 		 		// вывод картинки и очистка памяти 		imagejpeg($tmp, $out, $q); 		imagedestroy($in);				return true;	}//-----------------------------------------------------------------------------------IMAGE_FLIP		public function image_flip($in, $out, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;				$width   = imagesx ($in);		$height  = imagesy ($in);		$tmp     = imagecreatetruecolor($width, $height);				$y = 1;		while($y < $height){			for ($i = 1; $i <= $width; $i++)			imagesetpixel($tmp, $i, $y, imagecolorat($in, ($width - $i), ($y)));			$y += 1;		}		imagejpeg($tmp, $out, $q);		imagedestroy($tmp);		return true;	}//-----------------------------------------------------------------------------------WM		public function wm($in, $out, $wm, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;					//водяной знак должен быть квадратный, например (600*600), иначе криво ляжет!!!		$wm = @imagecreatefrompng($wm);				//если не определилось выходим		if(!$wm){ return false;}				$i_width  = imagesx($in);//530		$i_height = imagesy($in);//400				$wm_width  = imagesx($wm);//180		$wm_height = imagesy($wm);//180		imageAlphaBlending($in, true);//это для того что бы налаживался png сверху		imageAlphaBlending($wm, true);//это для того что бы налаживался png сверху		imagecopy($in, $wm, ($i_width - $wm_width)/2,($i_height - $wm_height)/2, 0, 0, $wm_width, $wm_height);				imagejpeg($in, $out, $q);		imagedestroy($in);		imagedestroy($wm);				return true;	}//-----------------------------------------------------------------------------------TEXTURA		public function textura($in, $out, $t, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;					//определяем есть ли PNG-текстура !!!		$t = @imagecreatefrompng($t);		if(!$t){ return false;}				$i_w = imagesx($in);//530		$i_h = imagesy($in);//400				$t_w = imagesx($t);//180		$t_h = imagesy($t);//180		imageAlphaBlending($in, true);//это для того что бы налаживался png сверху		imageAlphaBlending($t, true);//это для того что бы налаживался png сверху		imagecopy($in, $t, 0, 0, 0, 0, $t_w, $t_h);				imagejpeg($in, $out, $q);		imagedestroy($in);		imagedestroy($t);				return true;	}//-----------------------------------------------------------------------------------BLACK_WHITE	public function black_white($in, $out, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;					imagefilter($in, IMG_FILTER_GRAYSCALE);		imagefilter($in, IMG_FILTER_BRIGHTNESS, 40);		imagejpeg($in, $out, $q);		imagedestroy($in);				return true;	}//-----------------------------------------------------------------------------------SEPIA	public function sepia($in, $out, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;					imagefilter($in, IMG_FILTER_GRAYSCALE);		imagefilter($in, IMG_FILTER_BRIGHTNESS, -5);		imagefilter($in, IMG_FILTER_COLORIZE, 90, 45,0);		imagejpeg($in, $out, $q);		imagedestroy($in);				return true;	}//-----------------------------------------------------------------------------------NEGATIV	public function negativ($in, $out, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;					imagefilter($in, IMG_FILTER_NEGATE);		imagejpeg($in, $out, $q);		imagedestroy($in);				return true;	}//-----------------------------------------------------------------------------------RESIZE_BACKGROUND	public function resize_background($in, $out, $w, $h, $color = 0xffffff, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;				$width  = imagesx($in); 		$height = imagesy($in);		$x_ratio = $w / $width;  		$y_ratio = $h / $height;		$ratio       = min($x_ratio, $y_ratio);		$use_x_ratio = ($x_ratio == $ratio);		$new_width   = $use_x_ratio  ? $w  : floor($width * $ratio);		$new_height  = !$use_x_ratio ? $h : floor($height * $ratio);		$new_left    = $use_x_ratio  ? 0 : floor(($w - $new_width) / 2);		$new_top     = !$use_x_ratio ? 0 : floor(($h - $new_height) / 2);		$tmp = imagecreatetruecolor($w, $h);		imagefill($tmp, 0, 0, $color);		imagecopyresampled($tmp, $in, $new_left, $new_top, 0, 0, $new_width, $new_height, $width, $height);		imagejpeg($tmp, $out, $q);		imagedestroy($in);		imagedestroy($tmp);		return true;	}//-----------------------------------------------------------------------------------RESIZE	public function resize($in, $out, $size, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;				$w = imagesx($in);		$h = imagesy($in);		if($w > $h){			$kf    = $w/$size; 			$new_h = ceil($h/$kf);			$im1 = imagecreatetruecolor($size, $new_h);			imagecopyresampled($im1,$in,0,0,0,0,$size,$new_h,imagesx($in),imagesy($in));		}else{			$kf    = $h/$size; 			$new_w = ceil($w/$kf);			$im1 = imagecreatetruecolor($new_w, $size);			imagecopyresampled($im1,$in,0,0,0,0,$new_w,$size,imagesx($in),imagesy($in));		}		imagejpeg($im1, $out, $q);		imagedestroy($im1);		return true;	}//-----------------------------------------------------------------------------------RESIZE_2	public function resize_2($in, $out, $width, $height, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;				$w = imagesx($in);		$h = imagesy($in);				$max = max($w,$h);				if($max > $h){			$kf = $w/$width;			$new_h = ceil($h/$kf);			//доделано			if($new_h > $height){				$width = $width - ($new_h - $height);				$new_h = $height;			}			$tmp = imagecreatetruecolor($width, $new_h);			imagecopyresampled($tmp,$in,0,0,0,0,$width,$new_h,imagesx($in),imagesy($in));				/*imageconvolution($im1, array( // улучшаем четкость				array(-1,-1,-1),				array(-1,16,-1),				array(-1,-1,-1)				), 8, 0);*/		}else{			$kf = $h/$height;			$new_w = ceil($w/$kf);			$tmp = imagecreatetruecolor($new_w, $height);			imagecopyresampled($tmp,$in,0,0,0,0,$new_w,$height,imagesx($in),imagesy($in));			/*	imageconvolution($im1, array( // улучшаем четкость				array(-1,-1,-1),				array(-1,16,-1),				array(-1,-1,-1)				), 8, 0);*/		}		imagejpeg($tmp, $out, $q);		imagedestroy($tmp);		return true;	}//-----------------------------------------------------------------------------------RESIZE_3	public function resize_3($in, $out, $width, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;				$w = imagesx($in);		$h = imagesy($in);				$max = max($w,$h);				if($max > $h){			$kf = $w/$width;			$new_h = ceil($h/$kf);			$tmp = imagecreatetruecolor($width, $new_h);			imagecopyresampled($tmp,$in,0,0,0,0,$width,$new_h,imagesx($in),imagesy($in));				/*imageconvolution($im1, array( // улучшаем четкость				array(-1,-1,-1),				array(-1,16,-1),				array(-1,-1,-1)				), 8, 0);*/		}else{			$kf = $h/$height;			$new_w = ceil($w/$kf);			$tmp = imagecreatetruecolor($new_w, $height);			imagecopyresampled($tmp,$in,0,0,0,0,$new_w,$height,imagesx($in),imagesy($in));				/*imageconvolution($im1, array( // улучшаем четкость				array(-1,-1,-1),				array(-1,16,-1),				array(-1,-1,-1)				), 8, 0);*/		}		imagejpeg($tmp, $out, $q);		imagedestroy($tmp);		return true;	}//-----------------------------------------------------------------------------------RESIZE_SQUARE	public function resize_square($in, $out, $size, $q = 100){		if(!$in = $this->get_resourse($in)) 			return false;					// создаём пустую квадратную картинку 		// важно именно truecolor!, иначе будем иметь 8-битный результат 		$tmp = imagecreatetruecolor($size, $size); 				$w_src = imagesx($in);		$h_src = imagesy($in);				// вырезаем квадратную серединку по x, если фото горизонтальное 		if ($w_src>$h_src) 			imagecopyresampled($tmp, $in, 0, 0, round((max($w_src,$h_src)-min($w_src,$h_src))/2), 0, $size, $size, min($w_src,$h_src), min($w_src,$h_src));  		// вырезаем квадратную верхушку по y, 		// если фото вертикальное (хотя можно тоже серединку) 		if ($w_src<$h_src) 			imagecopyresampled($tmp, $in, 0, 0, 0, round((max($w_src,$h_src)-min($w_src,$h_src))/2), $size, $size, min($w_src,$h_src), min($w_src,$h_src)); 		// квадратная картинка масштабируется без вырезок 		if ($w_src==$h_src) 			imagecopyresampled($tmp, $in, 0, 0, 0, 0, $size, $size, $w_src, $w_src); 		 		// вывод картинки и очистка памяти 		imagejpeg($tmp, $out, $q); 		imagedestroy($tmp); 		imagedestroy($in);				return true;	}//-----------------------------------------------------------------------------------COLORATOR	public function colorator($in){		if(!$in = $this->get_resourse($in)) 			return false;					$colors = array('red'   =>0,					   'pink'   =>0,					   'orange' =>0,					   'yellow' =>0,					   'brown'  =>0,					   'violet' =>0,					   'blue'   =>0,					   'azure'  =>0,					   'green'  =>0,					   'grey'   =>0,					   'black'  =>0,					   'white'  =>0,					   'all'    =>0					   );		$r = 0;		$g = 0;		$b = 0;		$max = 0;		$min = 0;		$rg  = false;		$rb  = false;				$ix = imagesx($in);		$iy = imagesy($in);				for($x = 0; $x < $ix; $x++){      		for($y = 0; $y < $iy; $y++){         		$thisColor = imagecolorat($in, $x, $y);                 //imagecolorat()        --Получение индекса цвета пиксела ??????????????????????????????????????         		$rgb = imagecolorsforindex($in, $thisColor);            //imagecolorsforindex() -- Получение цветов, соответствующих индексу        		$r = round(round(($rgb['red'] / 0x33)) * 0x33);         		$g = round(round(($rgb['green'] / 0x33)) * 0x33);         		$b = round(round(($rgb['blue'] / 0x33)) * 0x33);								$rg  = ($r == $g);				$rb  = ($r == $b);				$max = max($r, $g, $b);				$min = min($r, $g, $b);								//начинаем поиск				$colors['all']++;								//поиск черного, белого, серого 				if ($rg && $rb){					if($r > 240){ 						$colors['white']++;						continue;					}elseif($r < 30){ 								$colors['black']++;						continue;					}else{ 						$colors['grey']++;						continue;					}				}else{					if($max < 30){ 						$colors['black']++; // черный						continue;					}else{						if($min > 240){ 							$colors['white']++; // белый								continue;						}					}				}								//если не определили идем дальше								//переводим RGB -> HSV (легче определить цвет)				//-------------------------------------------				$hsv = array('v' => $max / 2.55, 's' => (!$max) ? 0 : (1 - ($min / $max)) * 100, 'h' => 0);				$dmax = $max - $min;			 				if (!$dmax) return;			 				if ($max == $r){					if ($g < $b && $r != $b && $r < $b){						$hsv['h'] = ($g - $b) * 60; 					}elseif($g == $b){						$hsv['h'] = 360;					}else{						$hsv['h'] = ((($g - $b) / $dmax) * 60) + 360;					}			 				}elseif($max == $g){					$hsv['h'] = ((($b - $r) / $dmax) * 60) + 120;				}else{					$hsv['h'] = ((($r - $g) / $dmax) * 60) + 240;				}				//----------------------------------------------				//Перевели в HSV, идем дальше								//RED				if($hsv['h'] > 333 && $hsv['h'] < 382){ $colors['red']++; continue;}								//AZURE				if($hsv['h'] > 160 && $hsv['h'] < 228){ $colors['azure']++; continue;}				//BKUE				if($hsv['h'] > 227 && $hsv['h'] < 262){ $colors['blue']++; continue;}				//VIOLET				if($hsv['h'] > 261 && $hsv['h'] < 301){ $colors['violet']++; continue;}				//PINK				if($hsv['h'] > 300 && $hsv['h'] < 334){ $colors['pink']++; continue;}								//ORANGE				if($hsv['h'] > 381 && $hsv['h'] < 399){ 					if($hsv['s'] < 80 || $hsv['v'] < 80){						$colors['brown']++;						continue;					}					$colors['orange']++; 					continue;				}												//YELLOW				if(($hsv['h'] > 398 && $hsv['h'] < 425) or ($hsv['h'] > 38 && $hsv['h'] < 65)){ 					if($hsv['h'] < 410 || $hsv['h'] < 50){						if($hsv['s'] < 75 || $hsv['v'] < 75){							$colors['brown']++;							continue;						}					}					if($hsv['h'] > 415){						if($hsv['v'] < 70 && $hsv['v'] > 60){//if($hsv['s'] < 50 || $hsv['v'] < 60)							$colors['grey']++;//grey							continue;						}						if($hsv['s'] < 80 || $hsv['v'] < 85){//if($hsv['s'] < 50 || $hsv['v'] < 60)							$colors['green']++;//grey							continue;						}					}					$colors['yellow']++; 					continue;				}								//GREEN				if($hsv['h'] > 64  && $hsv['h'] < 161){					$colors['green']++; 					continue;				}      		}   		}				//переводим в проценты		$colors['red']    = ceil(($colors['red']*100)/$colors['all']);		$colors['orange'] = ceil(($colors['orange']*100)/$colors['all']);		$colors['yellow'] = ceil(($colors['yellow']*100)/$colors['all']);		$colors['green']  = ceil(($colors['green']*100)/$colors['all']);		$colors['azure']  = ceil(($colors['azure']*100)/$colors['all']);		$colors['blue']   = ceil(($colors['blue']*100)/$colors['all']);		$colors['violet'] = ceil(($colors['violet']*100)/$colors['all']);		$colors['pink']   = ceil(($colors['pink']*100)/$colors['all']);		$colors['white']  = ceil(($colors['white']*100)/$colors['all']);		$colors['grey']   = ceil(($colors['grey']*100)/$colors['all']);		$colors['black']  = ceil(($colors['black']*100)/$colors['all']);		$colors['brown']  = ceil(($colors['brown']*100)/$colors['all']);				imagedestroy($in);		return $colors;	}}//END?>